library(ContrApption)
ContrApption(
data = normCountsSig,
annotation = coldata,
groupCol = "type",
plotName = "DESeq2 normalized counts by sample types",
yAxisName = "counts"
)
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(ContrApption)
library(dplyr)
suppressMessages(library(DESeq2))
suppressMessages(library(pasilla))
# loads sample annotation from the pasilla package
pasAnno <- system.file("extdata", "pasilla_sample_annotation.csv", package = "pasilla", mustWork = TRUE)
# read in the sample data
coldata <- read.csv(pasAnno, row.names = 1)
# select relevant columns
coldata <- data.frame(coldata[ , c("condition","type")])
# remove un-needed characters
rownames(coldata) <- gsub("fb", "", rownames(coldata))
coldata
# loads counts file from the pasilla package
pasCts <- system.file("extdata", "pasilla_gene_counts.tsv", package = "pasilla", mustWork = TRUE)
# reads counts of genes
cts <- read.csv(pasCts, sep = "\t", row.names = "gene_id")
# make sure the order is correct
cts <- cts[, rownames(coldata)]
head(cts)
# create a DESeq2 dataset from the metadata and counts
dds <- DESeq(DESeqDataSetFromMatrix(countData = cts, colData = coldata, design = ~ condition))
normCounts <- counts(dds, normalized = TRUE)
res <- results(dds, tidy = TRUE) %>%
data.frame %>%
filter(padj < 0.05)
normCountsSig <- normCounts %>%
data.frame %>%
filter(rownames(.) %in% res$row)
normCountsSig %>% nrow
ContrApption(data = normCountsSig, annotation = coldata, groupCol = "condition")
ContrApption(
data = normCountsSig,
annotation = coldata,
groupCol = "type",
plotName = "DESeq2 normalized counts by sample types",
yAxisName = "counts"
)
# derive a new variable - every combitation of condition and type
coldata$interaction <- paste0(coldata$condition, ":", coldata$type)
head(coldata)
# pass our new variable
ContrApption(data = normCountsSig, annotation = coldata, groupCol = "interaction")
sessionInfo()
devtools::install()
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(ContrApption)
library(dplyr)
suppressMessages(library(DESeq2))
suppressMessages(library(pasilla))
# loads sample annotation from the pasilla package
pasAnno <- system.file("extdata", "pasilla_sample_annotation.csv", package = "pasilla", mustWork = TRUE)
# read in the sample data
coldata <- read.csv(pasAnno, row.names = 1)
# select relevant columns
coldata <- data.frame(coldata[ , c("condition","type")])
# remove un-needed characters
rownames(coldata) <- gsub("fb", "", rownames(coldata))
coldata
# loads counts file from the pasilla package
pasCts <- system.file("extdata", "pasilla_gene_counts.tsv", package = "pasilla", mustWork = TRUE)
# reads counts of genes
cts <- read.csv(pasCts, sep = "\t", row.names = "gene_id")
# make sure the order is correct
cts <- cts[, rownames(coldata)]
head(cts)
# create a DESeq2 dataset from the metadata and counts
dds <- DESeq(DESeqDataSetFromMatrix(countData = cts, colData = coldata, design = ~ condition))
normCounts <- counts(dds, normalized = TRUE)
res <- results(dds, tidy = TRUE) %>%
data.frame %>%
filter(padj < 0.05)
normCountsSig <- normCounts %>%
data.frame %>%
filter(rownames(.) %in% res$row)
normCountsSig %>% nrow
ContrApption(data = normCountsSig, annotation = coldata, groupCol = "condition")
ContrApption(
data = normCountsSig,
annotation = coldata,
groupCol = "type",
plotName = "DESeq2 normalized counts by sample types",
yAxisName = "counts"
)
# derive a new variable - every combitation of condition and type
coldata$interaction <- paste0(coldata$condition, ":", coldata$type)
head(coldata)
# pass our new variable
ContrApption(data = normCountsSig, annotation = coldata, groupCol = "interaction")
sessionInfo()
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(ContrApption)
library(dplyr)
suppressMessages(library(DESeq2))
suppressMessages(library(pasilla))
# loads sample annotation from the pasilla package
pasAnno <- system.file("extdata", "pasilla_sample_annotation.csv", package = "pasilla", mustWork = TRUE)
# read in the sample data
coldata <- read.csv(pasAnno, row.names = 1)
# select relevant columns
coldata <- data.frame(coldata[ , c("condition","type")])
# remove un-needed characters
rownames(coldata) <- gsub("fb", "", rownames(coldata))
coldata
# loads counts file from the pasilla package
pasCts <- system.file("extdata", "pasilla_gene_counts.tsv", package = "pasilla", mustWork = TRUE)
# reads counts of genes
cts <- read.csv(pasCts, sep = "\t", row.names = "gene_id")
# make sure the order is correct
cts <- cts[, rownames(coldata)]
head(cts)
# create a DESeq2 dataset from the metadata and counts
dds <- DESeq(DESeqDataSetFromMatrix(countData = cts, colData = coldata, design = ~ condition))
normCounts <- counts(dds, normalized = TRUE)
res <- results(dds, tidy = TRUE) %>%
data.frame %>%
filter(padj < 0.05)
normCountsSig <- normCounts %>%
data.frame %>%
filter(rownames(.) %in% res$row)
normCountsSig %>% nrow
ContrApption(data = normCountsSig, annotation = coldata, groupCol = "condition")
ContrApption(
data = normCountsSig,
annotation = coldata,
groupCol = "type",
plotName = "DESeq2 normalized counts by sample types",
yAxisName = "counts"
)
# derive a new variable - every combitation of condition and type
coldata$interaction <- paste0(coldata$condition, ":", coldata$type)
head(coldata)
# pass our new variable
ContrApption(data = normCountsSig, annotation = coldata, groupCol = "interaction")
sessionInfo()
system("./rebuildWithVignette.sh")
devtools::install()
devtools::install()
devtools::install()
system("./rebuildWithVignette.sh")
setwd("~/Dropbox (Partners HealthCare)/Workspace/ContrApptionPaper")
update.packages("rmarkdown")
sessionInfo()
knit_with_parameters('~/Dropbox (Partners HealthCare)/Workspace/ContrApptionPaper/TechnicalPaper.Rmd')
update.packages(ask=FALSE)
knit_with_parameters('~/Dropbox (Partners HealthCare)/Workspace/ContrApptionPaper/TechnicalPaper.Rmd')
knit_with_parameters('~/Dropbox (Partners HealthCare)/Workspace/ContrApptionPaper/TechnicalPaper.Rmd')
citation()
citation("htmlwidgets")
citation()
citation("pasilla")
citation("DESeq2")
citation("dplyr")
citation("htmltools")
citation("RStudio")
citation("knittr")
citation("knitr")
print(<citation>, bibtex=TRUE)
print(citation("knitr"), bibtex=TRUE)
citation("shiny")
citation("rmarkdown")
citation("devtools")
setwd("~/Dropbox (Partners HealthCare)/Workspace/RPackages/ContrApption")
setwd("~/Dropbox (Partners HealthCare)/Workspace/HFrEF_v_HFpEF_FullModel")
setwd("~/Dropbox (Partners HealthCare)/Workspace/HFrEF_v_HFpEF_FullModel")
system("./buildBook.sh")
git add .
system("./buildBook.sh")
# wrapping it as a function allows for it to be called by any given Rmd file
loadLibraries <- function()
{
suppressMessages(library(tidyverse))
suppressMessages(library(ggpubr))
suppressMessages(library(edgeR))
suppressMessages(library(reactable))
suppressMessages(library(multcomp))
suppressMessages(library(gplots))
suppressMessages(library(heatmaply))
suppressMessages(library(DESeq2))
suppressMessages(library(HGNChelper))
}
renv::activate()
install.packages("HGNChelper")
browseVignettes("HGNChelper")
# wrapping it as a function allows for it to be called by any given Rmd file
loadLibraries <- function()
{
suppressMessages(library(tidyverse))
suppressMessages(library(ggpubr))
suppressMessages(library(edgeR))
suppressMessages(library(reactable))
suppressMessages(library(multcomp))
suppressMessages(library(gplots))
suppressMessages(library(heatmaply))
suppressMessages(library(DESeq2))
suppressMessages(library(HGNChelper))
}
### runs a simple limma-voom analysis and returns the DGE and model
limmaVoom <- function(counts, samples, design)
{
### docs: "the voom transformation is applied to the normalized and filtered DGEList object"
# edgeR DE list
dge <- DGEList(counts = as.matrix(counts))
# created index of non-expressed for filtration
toKeep <- filterByExpr(dge, design)
# filter out non-expressed
dge <- dge[toKeep, ,keep.lib.sizes = FALSE]
### docs: "After this, the usual limma pipelines for differential expression can be applied
# voom adjustment
v <- voom(dge, design, plot = TRUE, normalize = "quantile")
# fit the model
fit <- lmFit(v, design)
# smoothing
fit <- eBayes(fit)
list(dge = dge, fit = fit)
}
runDESeq2 <- function(counts, samples, design)
{
DESeq(
DESeqDataSetFromMatrix(
countData = counts,
colData = samples,
design = design
)
)
}
filterWithFilterByExpr <- function(d, design, minCount = 10)
{
dge <- DGEList(counts = as.matrix(d))
# created index of non-expressed for filtration
toKeep <- filterByExpr(dge, design, min.count = minCount)
# filter out non-expressed
dge[toKeep, ,keep.lib.sizes = FALSE]$counts
}
filterByQuantileCutoff <- function(d, cutoff = 0.05)
{
d[which(rowMeans(d) > unname(quantile(rowMeans(d), cutoff)), 2), ]
}
coefByString <- function(str)
{
match(str, colnames(customMatrix))
}
### prepares normalized counts for visualization by annotating them from the sample sheet
prepLVCounts <- function(dCPM, gene, samplesData, log = FALSE)
{
# get the cpm table entry for that gene
geneData <- dCPM[gene, ]
# get the sample ids from 'named list'
samples <- names(geneData)
# get the numbers
count <- geneData %>% unname
# pivot the into a data frame
d <- cbind(count, samples) %>% data.frame
# get their metadata and fix types
d$count <- as.numeric(d$count)
d$Visit <- factor(samplesData$Visit[match(d$samples, samplesData$SampleID)], levels = c("Visit1", "Visit2"))
d$Group <- factor(samplesData$Group[match(d$samples, samplesData$SampleID)], levels = c("HFpEF", "HFrEF"))
d$MergedGroup <- factor(paste0(d$Group, ":", d$Visit),
levels = c("HFpEF:Visit1", "HFpEF:Visit2", "HFrEF:Visit1","HFrEF:Visit2"))
if(isTRUE(log)){
d$count <- log2(d$count)
}
na.omit(d)
}
prepDESeq2Counts <- function(dds, gene, samplesData, log = FALSE)
{
# get the DESeq2 normalized counts
d <- plotCounts(dds, gene = gene, intgroup = c("Group", "Visit"), returnData = TRUE) %>% na.omit
d$count <- as.integer(d$count)
# make a merged of Group and Status to facet on
d$MergedGroup <- paste0(d$Group, ":", d$Visit)
d$MergedGroup <- factor(d$MergedGroup, levels = c("HFpEF:Visit1", "HFpEF:Visit2", "HFrEF:Visit1", "HFrEF:Visit2"))
d$Visit <- factor(d$Visit, levels = c("Visit1", "Visit2"))
if(isTRUE(log)){
d$count <- log2(d$count)
}
na.omit(d)
}
plotGene <- function(d, x1, x2, colorBy, name, yLab, stats = FALSE, sharedLegend = TRUE)
{
oneFactorPlot <- ggboxplot(d, x = x1, y = "count", add = "jitter", color = colorBy, palette = "lancet", title = name, ylab = yLab)
multiFactorPlot <- ggboxplot(d, x = x2, y = "count", add = "jitter", color = colorBy, palette = "lancet", ylab = NULL)
if(isTRUE(stats)){
oneFactorPlot <- oneFactorPlot +
stat_compare_means(method = "t.test")
multiFactorPlot <- multiFactorPlot +
stat_compare_means(method = "t.test", comparisons = list(
c("HFpEF:Visit1", "HFpEF:Visit2"),
c("HFrEF:Visit1", "HFrEF:Visit2"),
c("HFrEF:Visit1", "HFpEF:Visit2"),
c("HFpEF:Visit1", "HFrEF:Visit2")
))
}
multiFactorPlot <- ggpar(multiFactorPlot, font.tickslab = c(8, "black"))
ggarrange(oneFactorPlot, multiFactorPlot, common.legend = sharedLegend)
}
topNAnalysis <- function(deObj, samples, contrast, x1, n, outString = NULL, cpm = NULL, log = FALSE)
{
# This is the function that does the plotting. It's made into a sub-function so that I can
# call it normally to show the results or in between pdf()/dev.off() to write the results
# the disk without have to duplicate the code.
plotTopN <- function()
{
# for each of the top N, make a plot
for(i in 1:nrow(resTopN)) {
# the gene in question
geneName <- rownames(resTopN)[i]
# get the counts data based on the tool
if(deTool == "limma-voom"){
dGene <- prepLVCounts(cpm, geneName, samples, log = log)
} else {
dGene <- prepDESeq2Counts(deObj, geneName, samples, log = log)
}
# add a star to the name is it's in significant post-pval adjustment
if(resTopN[, sigCol][i] < 0.05) {
geneName <- paste0(geneName, "*")
}
# plot the gene
plotGene(dGene, x1 = x1, x2 = "MergedGroup", colorBy = x1, name = geneName, yLab = yLab) %>% print
}
}
# the first step is to see if we're dealing with lv or DESeq2
if(class(deObj) == "MArrayLM") {
# set the tool name and the significance column
deTool <- "limma-voom"
sigCol <- "adj.P.Val"
yLab <- "CPM"
# get all the results with p adjusted sorted
resAll <- topTable(deObj, coef = coefByString(contrast), n = Inf) %>%
arrange(adj.P.Val)
resSig <- resAll %>%
filter(adj.P.Val < 0.05)
} else {
deTool <- "DESeq2"
sigCol <- "padj"
yLab <- "DESeq2 normalized counts"
resAll <- results(deObj, contrast = list(contrast)) %>%
data.frame %>%
arrange(padj)
resSig <- resAll %>%
filter(padj < 0.05)
}
# add log2 to the label if that's what we're doing
if(isTRUE(log)) {
yLab <- paste("log2", yLab)
}
# note number of sig genes in case it's > n
print(paste0("Number of significant after MH correction: ", nrow(resSig)))
# after the sort, there the first N are our top N
resTopN <- resAll[1:n, ]
# assign "A" to transcripts with padj < 0.05
resTopN$list <- sapply(resTopN[, sigCol], function(x){ ifelse(x < 0.05, "A", "B") })
# displays the plots in the book...
if(is.null(outString)){
plotTopN()
# ...or writes the plots to share
} else {
# format the the name for PDF and CSV
csvOut <- paste0(outString, "-top", n, ".csv")
pdfOut <- paste0(outString, "-top", n, ".pdf")
# write the plots to a pdf
pdf(pdfOut)
plotTopN()
dev.off()
write.csv(resTopN, csvOut)
}
# return the top
resTopN
}
cpmHeatmap <- function(cpm, title, margins, colAnnotation = NULL)
{
if(is.null(colAnnotation)) {
colAnnotation <- rep("white",28)
}
gplots::heatmap.2(
as.matrix(cpm),
main = title,
trace = "none",
col = rich.colors(10),
ColSideColors = colAnnotation,
margins = margins,
key.title = ""
)
}
# this is just so I can load the functions to compile chapters on their own if I want
# (without making them sources different instances of the functions)
save.image("analysisFunctions.RData")
# in case this chapter is compiled alone and not as part of a bookdown to save time
load("analysisFunctions.RData")
loadLibraries()
### See ValidateData.Rmd for the data cleaning steps
dataDir <- "/Users/Thadryan/Dropbox (Partners HealthCare)/Workspace/HFrEF_v_HFpEF_FullModel/"
lncData <- readRDS(paste0(dataDir, "analyses/processed-data/lncOriginalData.Rds"))
lncCounts <- lncData$counts
lncSamples <- lncData$samples
customMatrix <- readRDS(paste0(dataDir, "analyses/preprocessing/validatedCustomMatrix.Rds"))
lncLV <- limmaVoom(lncCounts, lncSamples, customMatrix)
lncFit <- lncLV$fit
# https://support.bioconductor.org/p/103747/#103769
lncNormCounts <- cpm(lncLV$dge, log = TRUE, prior.count = 3)
topNAnalysis(
deObj = lncFit,
cpm = lncNormCounts,
samples = lncSamples,
contrast = "GroupHFrEF",
x1 = "Group",
log = TRUE,
# include this to write files for end users upon bookdown compile, delete to render plots to book
#outString =  "analyses/TargetNominations2/lncRNA/Group/limma-voom-group",
n = 10
) %>% reactable(searchable = TRUE)
topNAnalysis(
deObj = lncFit,
cpm = lncNormCounts,
samples = lncSamples,
contrast = "VisitVisit2",
x1 = "Visit",
#outString =  "analyses/TargetNominations2/lncRNA/Visit/limma-voom-visit",
n = 10
) %>% reactable(searchable = TRUE)
topNAnalysis(
deObj = lncFit,
cpm = lncNormCounts,
samples = lncSamples,
contrast = "GroupHFrEF.VisitVisit2",
x1 = "Group",
# use to write files instead of compiling them into the book
#outString =  "analyses/TargetNominations2/lncRNA/Interaction/limma-voom-interaction",
n = 10
) %>% reactable(searchable = TRUE)
hmAnnotation <- as.character(lncSamples$Group[match(colnames(lncData$counts), lncSamples$SampleID)])
hmAnnotation[hmAnnotation == "HFrEF"] <- "Red"
hmAnnotation[hmAnnotation == "HFpEF"] <- "Blue"
cpmHeatmap(
lncNormCounts,
title = "CPM in HFrEF vs HFpEF - lncRNA",
colAnnotation = hmAnnotation,
margins = c(8,12)
)
legend(
"topright",
legend = c("HFrEF", "HFpEF"),
col = c("red", "blue"),
lty = 1:1,
box.lty = 1,
cex = 0.8
)
# use the limma-voom filtration for consistency
lncCounts <- filterWithFilterByExpr(lncCounts, customMatrix)
lncDESeq2Obj <- runDESeq2(lncCounts, lncSamples, customMatrix)
topNAnalysis(
deObj = lncDESeq2Obj,
samples = lncSamples,
contrast = "GroupHFrEF",
x1 = "Group",
#outString =  "analyses/TargetNominations2/lncRNA/Group/DESeq2-group",
n = 10
) %>% reactable(searchable = TRUE)
topNAnalysis(
deObj = lncDESeq2Obj,
samples = lncSamples,
contrast = "VisitVisit2",
x1 = "Visit",
#outString =  "analyses/TargetNominations2/lncRNA/Visit/DESeq2-visit",
n = 10
) %>% reactable(searchable = TRUE)
top <- topNAnalysis(
deObj = lncDESeq2Obj,
samples = lncSamples,
contrast = "GroupHFrEF.VisitVisit2",
x1 = "Group",
# outString =  "analyses/TargetNominations2/lncRNA/Interaction/DESeq2-interaction",
n = 10
)
top %>% reactable(searchable = TRUE)
checkGeneSymbols(rownames(top))
checkGeneSymbols(rownames(top), species = "human")
checkGeneSymbols(rownames(top), species = "human")
library(org.Hs.eg.db)
# set up your query genes
queryGeneNames <- c('WHRN', 'SANS')
# use sql to get alias table and gene_info table (contains the symbols)
# first open the database connection
dbCon <- org.Hs.eg_dbconn()
# write your SQL query
sqlQuery <- 'SELECT * FROM alias, gene_info WHERE alias._id == gene_info._id;'
# execute the query on the database
aliasSymbol <- dbGetQuery(dbCon, sqlQuery)
system("./buildBook.sh")
system("./buildBook.sh")
renv:::renv_paths_local()
setwd("~/Dropbox (Partners HealthCare)/Workspace/RPackages/ContrApption")
renv::activate()
renv::deactivate()
