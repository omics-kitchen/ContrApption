# assign "A" to transcripts with padj < 0.05
resTopN$list <- sapply(resTopN[, sigCol], function(x){ ifelse(x < 0.05, "A", "B") })
# displays the plots in the book...
if(is.null(outString)){
plotTopN()
# ...or writes the plots to share
} else {
# format the the name for PDF and CSV
csvOut <- paste0(outString, "-top", n, ".csv")
pdfOut <- paste0(outString, "-top", n, ".pdf")
# write the plots to a pdf
pdf(pdfOut)
plotTopN()
dev.off()
write.csv(resTopN, csvOut)
}
# return the top
resTopN
}
cpmHeatmap <- function(cpm, title, margins, counts, samples, group = "Group", idCol = "SampleID", colAnnotation = TRUE)
{
if(isFALSE(colAnnotation)) {
colAnnotation <- rep("white", 28)
} else {
colAnnotation <- as.character(samples[, group][match(colnames(counts), samples[, idCol])])
colAnnotation[colAnnotation == "HFrEF"] <- "Red"
colAnnotation[colAnnotation == "HFpEF"] <- "Blue"
}
gplots::heatmap.2(
as.matrix(cpm),
main = title,
trace = "none",
col = rich.colors(10),
ColSideColors = colAnnotation,
margins = margins,
key.title = ""
)
legend(
"topright",
legend = c("HFrEF", "HFpEF"),
col = c("red", "blue"),
lty = 1:1,
box.lty = 1,
cex = 0.8
)
}
# this is just so I can load the functions to compile chapters on their own if I want
# (without making them sources different instances of the functions)
save.image("analysisFunctions.RData")
# in case this chapter is compiled alone and not as part of a bookdown to save time
load("analysisFunctions.RData")
loadLibraries()
rnaType <- "lnc"
analysisTitle <- "Full"
# see ValidateData.Rmd for the data cleaning steps
dataDir <- "/Users/Thadryan/Dropbox (Partners HealthCare)/Workspace/HFrEF_v_HFpEF_FullModel/"
deData <- readRDS(paste0(dataDir, "analyses/processed-data/", rnaType, "OriginalData.Rds"))
heatmapTitle <- paste0("CPM in HFrEF vs HFpEF - ", rnaType, "RNA")
# outString <- paste0("analyses/AnalysisOutput/", analysisTitle, "/", rnaType, "RNA")
customMatrix <- readRDS(paste0(dataDir, "analyses/preprocessing/validatedCustomMatrix.Rds"))
deCounts <- deData$counts
deSamples <- deData$samples
rownames(deSamples) <- deSamples$SampleID
deLV <- limmaVoom(deCounts, deSamples, customMatrix)
deFit <- deLV$fit
deNormCounts <- cpm(deLV$dge, log = TRUE, prior.count = 3) # https://support.bioconductor.org/p/103747/#103769
lvGroup <- topNAnalysis(
deObj = deFit,
cpm = deNormCounts,
samples = deSamples,
contrast = "GroupHFrEF",
x1 = "Group",
x2 = "Visit",
log = TRUE,
subtitle = "WTF",
# include this to write files for end users upon bookdown compile, delete to render plots to book
# outString =  paste0(# outString, "/Group/limma-voom-group"),
n = 10
)
lvGroup %>% reactable(searchable = TRUE)
lvGroup <- topNAnalysis(
deObj = deFit,
cpm = deNormCounts,
samples = deSamples,
contrast = "GroupHFrEF",
x1 = "Group",
x2 = "Visit",
log = TRUE,
subtitle = "WTF",
# include this to write files for end users upon bookdown compile, delete to render plots to book
# outString =  paste0(# outString, "/Group/limma-voom-group"),
n = 10
)
lvGroup %>% reactable(searchable = TRUE)
# wrapping it as a function allows for it to be called by any given Rmd file
loadLibraries <- function()
{
suppressMessages(library(tidyverse))
suppressMessages(library(ggpubr))
suppressMessages(library(edgeR))
suppressMessages(library(reactable))
suppressMessages(library(multcomp))
suppressMessages(library(gplots))
suppressMessages(library(heatmaply))
suppressMessages(library(DESeq2))
suppressMessages(library(HGNChelper))
suppressMessages(library(tidyheatmaps))
suppressMessages(library(crosstalk))
suppressMessages(library(DT))
suppressWarnings(library(ContrApption))
}
### runs a simple limma-voom analysis and returns the DGE and model
limmaVoom <- function(counts, samples, design)
{
### docs: "the voom transformation is applied to the normalized and filtered DGEList object"
# edgeR DE list
dge <- DGEList(counts = as.matrix(counts))
# created index of non-expressed for filtration
toKeep <- filterByExpr(dge, design)
# filter out non-expressed
dge <- dge[toKeep, ,keep.lib.sizes = FALSE]
### docs: "After this, the usual limma pipelines for differential expression can be applied
# voom adjustment
v <- voom(dge, design, plot = TRUE, normalize = "quantile")
# fit the model
fit <- lmFit(v, design)
# smoothing
fit <- eBayes(fit)
list(dge = dge, fit = fit)
}
runDESeq2 <- function(counts, samples, design)
{
DESeq(
DESeqDataSetFromMatrix(
countData = counts,
colData = samples,
design = design
)
)
}
filterWithFilterByExpr <- function(d, design, minCount = 10)
{
dge <- DGEList(counts = as.matrix(d))
# created index of non-expressed for filtration
toKeep <- filterByExpr(dge, design, min.count = minCount)
# filter out non-expressed
dge[toKeep, ,keep.lib.sizes = FALSE]$counts
}
coefByString <- function(str)
{
match(str, colnames(customMatrix))
}
### prepares normalized counts for visualization by annotating them from the sample sheet
prepLVCounts <- function(dCPM, gene, samplesData, log = FALSE)
{
# get the cpm table entry for that gene
geneData <- dCPM[gene, ]
# get the sample ids from 'named list'
samples <- names(geneData)
# get the numbers
count <- geneData %>% unname
# pivot the into a data frame
d <- cbind(count, samples) %>% data.frame
# get their metadata and fix types
d$count <- as.numeric(d$count)
d$Visit <- factor(samplesData$Visit[match(d$samples, samplesData$SampleID)], levels = c("Visit1", "Visit2"))
d$Group <- factor(samplesData$Group[match(d$samples, samplesData$SampleID)], levels = c("HFpEF", "HFrEF"))
d$MergedGroup <- factor(paste0(d$Group, ":", d$Visit),
levels = c("HFpEF:Visit1", "HFpEF:Visit2", "HFrEF:Visit1","HFrEF:Visit2"))
if(isTRUE(log)){
d$count <- log2(d$count)
}
na.omit(d)
}
prepDESeq2Counts <- function(dds, gene, samplesData, log = FALSE)
{
# get the DESeq2 normalized counts
d <- plotCounts(dds, gene = gene, intgroup = c("Group", "Visit"), returnData = TRUE) %>% na.omit
d$count <- as.integer(d$count)
# make a merged of Group and Status to facet on
d$MergedGroup <- paste0(d$Group, ":", d$Visit)
d$MergedGroup <- factor(d$MergedGroup, levels = c("HFpEF:Visit1", "HFpEF:Visit2", "HFrEF:Visit1", "HFrEF:Visit2"))
d$Visit <- factor(d$Visit, levels = c("Visit1", "Visit2"))
if(isTRUE(log)){
d$count <- log2(d$count)
}
na.omit(d)
}
plotGene <- function(d, x1, x2, colorBy, name, yLab, contrast, stats = FALSE, subtitle = NULL, sharedLegend = TRUE, mode = "interaction")
{
leftPlot <- ggboxplot(d, x = x1, y = "count", add = "jitter", color = colorBy, palette = "lancet", title = name, ylab = yLab)
rightPlot <- ggboxplot(d, x = x2, y = "count", add = "jitter", color = colorBy, palette = "lancet", ylab = NULL)
if(mode == "abstract") {
dRight <- d %>%
filter(Visit == "Visit1")
rightPlot <- ggboxplot(dRight, x = x2, y = "count", add = "jitter", color = colorBy, palette = "lancet", ylab = NULL)
}
if(is.null(subtitle)) {
print("hi")
subtitle <- contrast
}
leftPlot <- ggpar(leftPlot, subtitle = subtitle, font.tickslab = c(8, "black"))
rightPlot <- ggpar(rightPlot, font.tickslab = c(8, "black"))
ggarrange(leftPlot, rightPlot, common.legend = sharedLegend)
}
# plotGeneAbstract <- function(d, x1, x2, colorBy, name, yLab, contrast, stats = FALSE, sharedLegend = TRUE)
# {
#
#   dRight <- d %>%
#     filter(Visit == "Visit1")
#
#   leftPlot <- ggboxplot(d, x = x2, y = "count", add = "jitter", color = colorBy, palette = "lancet", title = name, ylab = "CPM")
#
#   rightPlot <- ggboxplot(dRight, x = x1, y = "count", add = "jitter", color = "Group", palette = "lancet", ylab = NULL)
#
#
#   if(isTRUE(stats)){
#
#     oneFactorPlot <- oneFactorPlot +
#       stat_compare_means(method = "t.test")
#
#     multiFactorPlot <- multiFactorPlot +
#       stat_compare_means(method = "t.test", comparisons = list(
#         c("HFpEF:Visit1", "HFpEF:Visit2"),
#         c("HFrEF:Visit1", "HFrEF:Visit2"),
#         c("HFrEF:Visit1", "HFpEF:Visit2"),
#         c("HFpEF:Visit1", "HFrEF:Visit2")
#     ))
#   }
#
#   leftPlot <- ggpar(leftPlot, subtitle = contrast, font.tickslab = c(8, "black"))
#
#   ggarrange(leftPlot, rightPlot, common.legend = sharedLegend)
# }
topNAnalysis <- function(deObj, samples, contrast, x1, n, x2 = "MergedGroup", plotMode = "interaction", subtitle = NULL, outString = NULL, cpm = NULL, log = FALSE)
{
# This is the function that does the plotting. It's made into a sub-function so that I can
# call it normally to show the results or in between pdf()/dev.off() to write the results
# the disk without have to duplicate the code.
plotTopN <- function()
{
# for each of the top N, make a plot
for(i in 1:nrow(resTopN)) {
# the gene in question
geneName <- rownames(resTopN)[i]
# get the counts data based on the tool
if(deTool == "limma-voom"){
dGene <- prepLVCounts(cpm, geneName, samples, log = log)
} else {
dGene <- prepDESeq2Counts(deObj, geneName, samples, log = log)
}
# add a star to the name is it's in significant post-pval adjustment
if(resTopN[, sigCol][i] < 0.05) {
geneName <- paste0(geneName, "*")
}
# plot the gene
plotGene(dGene, x1 = x1, x2 = x2, colorBy = x1, name = geneName, yLab = yLab, contrast = contrast, subtitle = subtitle) %>% print
}
}
# the first step is to see if we're dealing with lv or DESeq2
if(class(deObj) == "MArrayLM") {
# set the tool name and the significance column
deTool <- "limma-voom"
sigCol <- "adj.P.Val"
yLab <- "CPM"
# get all the results with p adjusted sorted
resAll <- topTable(deObj, coef = coefByString(contrast), n = Inf) %>%
arrange(adj.P.Val)
resSig <- resAll %>%
filter(adj.P.Val < 0.05)
} else {
deTool <- "DESeq2"
sigCol <- "padj"
yLab <- "DESeq2 normalized counts"
resAll <- results(deObj, contrast = list(contrast)) %>%
data.frame %>%
arrange(padj)
resSig <- resAll %>%
filter(padj < 0.05)
}
# add log2 to the label if that's what we're doing
if(isTRUE(log)) {
yLab <- paste("log2", yLab)
}
# note number of sig genes in case it's > n
print(paste0("Number of significant after MH correction: ", nrow(resSig)))
# after the sort, there the first N are our top N
resTopN <- resAll[1:n, ]
# assign "A" to transcripts with padj < 0.05
resTopN$list <- sapply(resTopN[, sigCol], function(x){ ifelse(x < 0.05, "A", "B") })
# displays the plots in the book...
if(is.null(outString)){
plotTopN()
# ...or writes the plots to share
} else {
# format the the name for PDF and CSV
csvOut <- paste0(outString, "-top", n, ".csv")
pdfOut <- paste0(outString, "-top", n, ".pdf")
# write the plots to a pdf
pdf(pdfOut)
plotTopN()
dev.off()
write.csv(resTopN, csvOut)
}
# return the top
resTopN
}
cpmHeatmap <- function(cpm, title, margins, counts, samples, group = "Group", idCol = "SampleID", colAnnotation = TRUE)
{
if(isFALSE(colAnnotation)) {
colAnnotation <- rep("white", 28)
} else {
colAnnotation <- as.character(samples[, group][match(colnames(counts), samples[, idCol])])
colAnnotation[colAnnotation == "HFrEF"] <- "Red"
colAnnotation[colAnnotation == "HFpEF"] <- "Blue"
}
gplots::heatmap.2(
as.matrix(cpm),
main = title,
trace = "none",
col = rich.colors(10),
ColSideColors = colAnnotation,
margins = margins,
key.title = ""
)
legend(
"topright",
legend = c("HFrEF", "HFpEF"),
col = c("red", "blue"),
lty = 1:1,
box.lty = 1,
cex = 0.8
)
}
# this is just so I can load the functions to compile chapters on their own if I want
# (without making them sources different instances of the functions)
save.image("analysisFunctions.RData")
# in case this chapter is compiled alone and not as part of a bookdown to save time
load("analysisFunctions.RData")
loadLibraries()
rnaType <- "lnc"
analysisTitle <- "Full"
# see ValidateData.Rmd for the data cleaning steps
dataDir <- "/Users/Thadryan/Dropbox (Partners HealthCare)/Workspace/HFrEF_v_HFpEF_FullModel/"
deData <- readRDS(paste0(dataDir, "analyses/processed-data/", rnaType, "OriginalData.Rds"))
heatmapTitle <- paste0("CPM in HFrEF vs HFpEF - ", rnaType, "RNA")
# outString <- paste0("analyses/AnalysisOutput/", analysisTitle, "/", rnaType, "RNA")
customMatrix <- readRDS(paste0(dataDir, "analyses/preprocessing/validatedCustomMatrix.Rds"))
deCounts <- deData$counts
deSamples <- deData$samples
rownames(deSamples) <- deSamples$SampleID
deLV <- limmaVoom(deCounts, deSamples, customMatrix)
deFit <- deLV$fit
deNormCounts <- cpm(deLV$dge, log = TRUE, prior.count = 3) # https://support.bioconductor.org/p/103747/#103769
lvGroup <- topNAnalysis(
deObj = deFit,
cpm = deNormCounts,
samples = deSamples,
contrast = "GroupHFrEF",
x1 = "Group",
x2 = "Visit",
log = TRUE,
subtitle = "WTF",
# include this to write files for end users upon bookdown compile, delete to render plots to book
# outString =  paste0(# outString, "/Group/limma-voom-group"),
n = 10
)
lvGroup %>% reactable(searchable = TRUE)
# in case this chapter is compiled alone and not as part of a bookdown to save time
load("analysisFunctions.RData")
loadLibraries()
rnaType <- "lnc"
analysisTitle <- "Full"
# see ValidateData.Rmd for the data cleaning steps
dataDir <- "/Users/Thadryan/Dropbox (Partners HealthCare)/Workspace/HFrEF_v_HFpEF_FullModel/"
deData <- readRDS(paste0(dataDir, "analyses/processed-data/", rnaType, "OriginalData.Rds"))
heatmapTitle <- paste0("CPM in HFrEF vs HFpEF - ", rnaType, "RNA")
# outString <- paste0("analyses/AnalysisOutput/", analysisTitle, "/", rnaType, "RNA")
customMatrix <- readRDS(paste0(dataDir, "analyses/preprocessing/validatedCustomMatrix.Rds"))
deCounts <- deData$counts
deSamples <- deData$samples
rownames(deSamples) <- deSamples$SampleID
deLV <- limmaVoom(deCounts, deSamples, customMatrix)
deFit <- deLV$fit
deNormCounts <- cpm(deLV$dge, log = TRUE, prior.count = 3) # https://support.bioconductor.org/p/103747/#103769
lvGroup <- topNAnalysis(
deObj = deFit,
cpm = deNormCounts,
samples = deSamples,
contrast = "GroupHFrEF",
x1 = "Group",
x2 = "Visit",
log = TRUE,
subtitle = "HFpEF vs HFrEF",
# include this to write files for end users upon bookdown compile, delete to render plots to book
# outString =  paste0(# outString, "/Group/limma-voom-group"),
n = 10
)
lvGroup %>% reactable(searchable = TRUE)
lvVisit <- topNAnalysis(
deObj = deFit,
cpm = deNormCounts,
samples = deSamples,
contrast = "VisitVisit2",
x1 = "Visit",
# outString =  paste0(# outString, "/Visit/limma-voom-visit"),
n = 10,
plotMode = "interaction"
)
lvVisit %>% reactable(searchable = TRUE)
lvInteraction <- topNAnalysis(
deObj = deFit,
cpm = deNormCounts,
samples = deSamples,
contrast = "GroupHFrEF.VisitVisit2",
x1 = "Group",
x2 = "Visit",
# outString =  paste0(# outString, "/Interaction/limma-voom-interaction"),
n = 10
)
lvInteraction %>% reactable(searchable = TRUE)
countsShared <- SharedData$new(deCounts)
datatable(countsShared, selection = 'single')
ContrApption(data = countsShared, annotation = deSamples)
cpmHeatmap(
cpm = deNormCounts,
title = heatmapTitle,
margins = c(8,12),
counts = deCounts,
samples = deSamples
)
# use the limma-voom filtration for consistency
deDESeq2Obj <- runDESeq2(filterWithFilterByExpr(deCounts, customMatrix), deSamples, customMatrix)
desGroup <- topNAnalysis(
deObj = deDESeq2Obj,
samples = deSamples,
contrast = "GroupHFrEF",
x1 = "Group",
x2 = "Visit",
# outString =  paste0(# outString, "/Group/DESeq2-group"),
n = 10
)
desGroup %>% reactable(searchable = TRUE)
desVisit <- topNAnalysis(
deObj = deDESeq2Obj,
samples = deSamples,
contrast = "VisitVisit2",
x1 = "Visit",
# outString =  paste0(# outString, "/Visit/DESeq2-visit"),
n = 10
)
desVisit %>% reactable(searchable = TRUE)
desInteraction <- topNAnalysis(
deObj = deDESeq2Obj,
samples = deSamples,
contrast = "GroupHFrEF.VisitVisit2",
x1 = "Group",
# outString = paste0(# outString, "/Interaction/DESeq2-interaction"),
n = 10
)
desInteraction %>% reactable(searchable = TRUE)
### prepares normalized counts for visualization by annotating them from the sample sheet
prepLVCounts <- function(dCPM, gene, samplesData, log = FALSE)
{
# get the cpm table entry for that gene
geneData <- dCPM[gene, ]
# get the sample ids from 'named list'
samples <- names(geneData)
# get the numbers
count <- geneData %>% unname
# pivot the into a data frame
d <- cbind(count, samples) %>% data.frame
# get their metadata and fix types
d$count <- as.numeric(d$count)
d$Visit <- factor(samplesData$Visit[match(d$samples, samplesData$SampleID)], levels = c("Visit1", "Visit2"))
d$Group <- factor(samplesData$Group[match(d$samples, samplesData$SampleID)], levels = c("HFpEF", "HFrEF"))
d$MergedGroup <- factor(paste0(d$Group, ":", d$Visit),
levels = c("HFpEF:Visit1", "HFpEF:Visit2", "HFrEF:Visit1","HFrEF:Visit2"))
if(isTRUE(log)){
d$count <- log2(d$count)
}
na.omit(d)
}
plotGeneAbstract <- function(d, x1, x2, colorBy, name, yLab, stats = FALSE, sharedLegend = TRUE)
{
dRight <- d %>%
filter(Visit=="Visit1")
leftPlot <- ggboxplot(d, x = x2, y = "count", add = "jitter", color = colorBy, palette = "lancet", title = name, ylab = "NULL")
rightPlot <- ggboxplot(dRight, x = x1, y = "count", add = "jitter", color = "Group", palette = "lancet", ylab = NULL)
if(isTRUE(stats)){
oneFactorPlot <- oneFactorPlot +
stat_compare_means(method = "t.test")
multiFactorPlot <- multiFactorPlot +
stat_compare_means(method = "t.test", comparisons = list(
c("HFpEF:Visit1", "HFpEF:Visit2"),
c("HFrEF:Visit1", "HFrEF:Visit2"),
c("HFrEF:Visit1", "HFpEF:Visit2"),
c("HFpEF:Visit1", "HFrEF:Visit2")
))
}
leftPlot <- ggpar(leftPlot, font.tickslab = c(8, "black"))
ggarrange(leftPlot, rightPlot, common.legend = sharedLegend)
}
# You are right. Just to be clear  - on the right I would like just HFpEF vs HFrEF
# (visit 1 only but labelled as group) ; on the right both visits between HFpEF and HFrEF.
x <- prepDESeq2Counts(dds = deDESeq2Obj, gene = "AC004147.2", samplesData = deSamples, log = FALSE)
plotGeneAbstract(x, "Group", "Visit", "Group", "AC004147.2", "ylab")
x <- prepLVCounts(dCPM = deNormCounts, gene = "PEG13", samplesData = deSamples, log = FALSE)
plotGeneAbstract(x, "Group", "Visit", "Group", "PEG13", "ylab")
system("./buildBook.sh")
system("./buildBook.sh")
system("./buildBook.sh")
